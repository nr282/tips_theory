"""
Problem Solving Theory

1. Understand the Problem
2. Design a Plan
    1. Analogy
    2. Analysis
    3. Similar Problem
    4. Draw diagram
    5. Add auxillary element
        - Calculate something that is useful.
        - This could be looking for an invariant.
        - This could be playing with the problem quickly.
        -
    6. Add auxiallary problem
    7. Write down all relevant ideas
    8. Look at different perspectives in the problem.
    9. Look for a different set of perspectives on the problem.
        1. Perspective Problem
            1. Binary Search. Is there a way of reducing the search space?
            2. can we construct isValid for binary search?
            3. Sliding Window
                - for loop with a while loop
                - TODO: Need a template for this.
            4. DFS
                - TODO: Good for searching the graph.
            5. BFS
                - TODO: Good for searching the graph.
                - TODO: Can use two BFS from different nodes
            6. Sliding Window
                - TODO:
            7. Backtracking
                - Enumerate all choices
                - Efficiently backtrack from a particular choice.
            8. Dynamic Programming
                - What at the sub problems.
                - What should be the indicies for the sub problems
            9. Greedy Algorithm
                - Play with problem to find optimal method
            10. Divide and Conquer
                - divide the problem and then solve each sub-problem. "Merge Sort"
            11. Bit Manipulation
            12. Sorting
            13. Graph Theory
                -
            14. Trie
                - TODO:
            15. Hash Table
            16. Stack
                - TODO: How can we look at using the stack.
                - TODO: The calculation of a simple array problem can be solved via a stack.
            16. Queue
            17. Heap
                - TODO: Keeps track of the highest element that is available.
            18.
3. Carry Out the Plan
    1. Calcluate ahead of time what can be done.
    2. Try to look at what is the cleanest code that can be written.
    3.
4. Check the result
    1. TODO: Look at if the results are correct.
    2. TODO: Use small edge cases to determine if this correct.
    3. TODO: Does the result make sense?
    4. TODO:

Ask yourself the questions:
    1. What are you asked to find or show?
    2. Can you restate the question in your own words?
    3. What part of the information/problem are you examining
    4. Can you think of a picture or diagram that can help you understand the question
    5. Do you understand all the words used in stating the question?
    6. Why might this problem be difficult or easy?

Possible Strategies:
    1.  Draw pictures or diagrams
    2. Eliminate Possibilities
    3. Be systematics
    4. Solve a simpler version of the problem. Consider special cases.
    5. Guess and Check. Trial and Error. Guess and test
    6. Look for a pattern or patterns
        - Ask yourself what is the structure?
        - Ask yourself what is the relationship between elements?
        - Draw the structure, or state the structure?
        - Restate the said structure?
    7. Make a list, write down key ideas/words

Review:
    1. Review the problem or system.
    2. Understand all the anciliary, second-order lemmas.
        - Placing information in a dictionary
        - Dividing the range?


------------------------------------------------------------------------------------------------------------------------
In a great number of problems, the problems are complicated and often difficult to understand.

The best way to understand a complicated problem is to draw diagrams, add auxillary elements, add auxillary problems
and make observations about the problem.



1. Entry Phase
    - Read the problem.
    - Read the problem.
    - Read the problem.
    - Draw a diagram expressing the problem.
    - Draw simple example
    - Draw complex examples
        - Make sure it has a sufficient amount, but not too much amount so as to reveal core difficulties.
    - Draw relevant examples that may have certain difficulties.
        - Each problem may have an example that have a extreme amount of difficulty.
2. Attack Phase
    - What methods can be used to attack the problem.
        - We can use the Entry Phase to inform the methods and techniques.
        - From the drawn examples, the solution method should reveal itself.
    - Keep a list of all relevant possible solution methods:
        1. For each set of problems, these could be theorems or auxillary solutions (lemmas).
        2. Likewise, this could be a set of algorithms.
        3.
3. Review/Extend
    1. Review the solutions that were developed to extend the problem solving solution.
    2. It is the review that will be critical to increased understanding.
    3.





"""